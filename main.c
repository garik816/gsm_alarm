/*
 * main.c
 *
 *  Created on: 18 февр. 2016
 *      Author: g@rik
 *
 *		ATmega8
 *		внутренний кварц 8 Mgz
 *
 *
 *      to do list:
 *
 *      - повесить светодиод, будет мигать с определенным периодом  //есть
 *      - повесить светодиод на аларм								//надо
 *		- повесить интерфейс программирования + кварц				//под вонросом
 *      -
 *      -
 *		-
 *      - пробовать													//есть - работает (22.03.16)
 *      -
 *      - как сделать общий сброс программы?
 *		-
 *      -
 *		-
 */

#include <avr/io.h>
#include <util/delay.h> 								// подключаем библиотеку задержки
#include <avr/interrupt.h>								// подключаем библиотеку прерываний
#include <stdlib.h>




volatile char status; 									//Хранение статусов
#define PROTECT     0 									//Флаг включения системы защиты
#define WARNING     1 									//Флаг включения сигнализации
#define ALARM    	2 									//Флаг разрешения мигания красного светодиода
#define SECRET_SET  3 									//Флаг нажатия резервной кнопки

volatile char sensor;
#define HERCON		0
#define VIBRO		1
#define RESET		2



#define Bit_is_set(val, bit)   ((val & (1<<(bit)))!=0)
#define Bit_is_clear(val, bit)   ((val & (1<<(bit)))==0)
#define Bit_set(val, bit)   (val) |= ((1<<(bit)))
#define Bit_reset(val, bit)   (val) &= (~(1<<(bit)))





int init_UART(void)
{
	//	Установка скорости 9600
	UBRRH=0;	//	UBRR=f/(16*band)-1 f=8000000Гц band=9600,
	UBRRL=51;	//	нормальный асинхронный двунаправленный режим работы

//			RXC			-	завершение приёма
//			|TXC		-	завершение передачи
//			||UDRE 		-	отсутствие данных для отправки
//			|||FE		-	ошибка кадра
//			||||DOR		-	ошибка переполнение буфера
//			|||||PE		-	ошибка чётности
//			||||||U2X	-	Двойная скорость
//			|||||||MPCM	-	Многопроцессорный режим
//			76543210
	UCSRA=0b00000000;

//			RXCIE		-	прерывание при приёме данных
//			|TXCIE		-	прерывание при завершение передачи
//			||UDRIE		-	прерывание отсутствие данных для отправки
//			|||RXEN		-	разрешение приёма
//			||||TXEN	-	разрешение передачи
//			|||||UCSZ2	-	UCSZ0:2 размер кадра данных
//			||||||RXB8	-	9 бит принятых данных
//			|||||||TXB8	-	9 бит переданных данных
//			76543210
	UCSRB=0b00011000;	//	разрешен приём и передача по UART

//			URSEL		-	всегда 1
//			|UMSEL		-	режим:1-синхронный 0-асинхронный
//			||UPM1		-	UPM0:1 чётность
//			|||UPM0		-	UPM0:1 чётность
//			||||USBS	-	топ биты: 0-1, 1-2
//			|||||UCSZ1	-	UCSZ0:2 размер кадра данных
//			||||||UCSZ0	-	UCSZ0:2 размер кадра данных
//			|||||||UCPOL-	в синхронном режиме - тактирование
//			76543210
	UCSRC=0b10000110;	//	8-битовая посылка
	return(1);
}

void send_Uart(unsigned char c)//	Отправка байта
{
	while(!(UCSRA&(1<<UDRE)))	//	Устанавливается, когда регистр свободен
	{}
	UDR = c;
}

void send_Uart_str(char *s)//	Отправка строки
{
	while (*s != 0) send_Uart(*s++);
}

void send_int_Uart(unsigned int c)//	Отправка числа от 0000 до 9999
{
	unsigned char temp;
	c=c%10000;
	temp=c/100;
	send_Uart(temp/10+'0');
	send_Uart(temp%10+'0');
	temp=c%100;;
	send_Uart(temp/10+'0');
	send_Uart(temp%10+'0');
}

int main(void)
{

	//////////////////////////////////////////////////////
	start:												//		закладка для goto
	sensor=0;											//		сброс переменных
	status=0;											//
	cli();												//
	//////////////////////////////////////////////////////




	// инициализация и назначение портов
	DDRC	= 0b00010001;
	PORTC	= 0b00101110;
	DDRD	= 0b10000000;
	PORTD	= 0b00000000;

	init_UART();				//	инициализация UART
	_delay_ms(1000);			//	задержка 1c

//	send_Uart_str("secret - ok\n\r");					//debug
//	send_Uart_str("warning_hercon - ok\n\r");			//debug
//	send_Uart_str("warning_vibro - ok\n\r");			//debug
	send_Uart_str("start\n\r");							//debug



		////*значение для счетного регистра*////////////// при 8 Мц, TCCR1B = (1<<CS12)|(0<<CS11)|(0<<CS10), TCNT1 = 34336 - прерывание = 1000мс
		TCCR1B = (1<<CS12)|(0<<CS11)|(0<<CS10); 		// настраиваем делитель (частота прерывания)
		TIMSK |= (1<<TOIE1); 							// разрешаем прерывание по переполнению таймера
		TCNT1 = 34336;        							// выставляем начальное значение TCNT1
		//////////////////////////////////////////////////

		/////*значение для счетного регистра*///////////// при 8 Мц, TCCR0 = (1<<CS12)|(0<<CS11)|(1<<CS10), TCNT0 = 60 - прерывание = 25мс
		TCCR0 = (1<<CS12)|(0<<CS11)|(1<<CS10); 			// настраиваем делитель (частота прерывания)
		TIMSK |= (1<<TOIE0); 							// разрешаем прерывание по переполнению таймера
		TCNT0 = 60;        								// выставляем начальное значение TCNT0
		//////////////////////////////////////////////////


		//////////////////////////////////////////////////
		for(int i=0;i<10;i++)							//	тупо ждем ~90 секунд перед прерыванием
			{											//
			_delay_ms(1000);							//
			i++;										//
			}											//
		//////////////////////////////////////////////////


		/////////	отправка SMS	//////////////////////
		send_Uart_str("AT+CMGS=\"+380501025052\"\n\r");	//	номер
		send_Uart_str("alarm_ARMED");					//	текст
		send_Uart(26);									//
		send_Uart_str("\n\r");							//
		//////////////////////////////////////////////////




		sei();											//	разрешаем прерывания

		for(;;)											//	бесконечный цикл
		{
			if(Bit_is_set(sensor, RESET))				// 	если поступила команда сброс - переходим в начало программы
			{
				send_Uart_str("reset\n\r");		//debug
				send_int_Uart(sensor);			//debug
				send_int_Uart(status);			//debug
				send_Uart_str("\n\r");			//debug
				goto start;
			}
		}
}



ISR(TIMER1_OVF_vect)		//работа с флагами (каждые 1000мс)
{
	TCNT1 = 34336;			//перезапись счетного регистра
//	PORTC ^= (1<<4);		//debug

		//////	 выключатель сигнализации (тумблер)		//////
		if(Bit_is_set(sensor, RESET))						//
			{												//
				Bit_reset(sensor, RESET);					//
				Bit_set(status, SECRET_SET);				//
//				send_Uart_str("secret\n\r");	//debug		//
			}												//
		//////////======================================//////

		/////////		 опрос геркона на обрыв			//////
		if(Bit_is_set(sensor, HERCON))						//
			{												//
				Bit_reset(sensor, HERCON);					//
				Bit_set(status, ALARM);						//
//				send_Uart_str("hercon\n\r");	//debug		//
			}												//
		//////////======================================//////

		///////	 опрос вибродатчика ("0" - сработка)	//////
		if(Bit_is_set(sensor, VIBRO))						//
			{												//
				Bit_reset(sensor, VIBRO);					//
				Bit_set(status, WARNING);					//
//				send_Uart_str("vibro\n\r");		//debug		//
			}												//
		//////////======================================//////




		//////  		обработка статусов			//////////
		if(Bit_is_set(status, SECRET_SET))					//
			{												//
//				send_Uart_str("SECRET\n\r");	//debug		//
				status = 0;									//
				PORTC &= (~(1<<0));							//
			}												//
															//
		if(Bit_is_set(status, ALARM))						//
			{												//
//				PORTC ^= (1<<4);				//debug		//
//				send_Uart_str("ALARM\n\r");		//debug		//
				PORTC |= (1<<0);							//
				send_Uart_str("ATD+380501025052;\n\r");		//	звонок
			}												//
															//
		if(Bit_is_set(status, WARNING))						//
			{												//
//				PORTC ^= (1<<0);				//debug		//
//				send_Uart_str("WARNING\n\r");	//debug		//
				PORTC |= (1<<0);							//
				send_Uart_str("ATD+380501025052;\n\r");		//	звонок
			}												//
		//////////////////////////////////////////////////////





}

ISR(TIMER0_OVF_vect)			//опрос датчиков (каждые 25мс)
{

	TCNT0 = 60; 			//перезапись счетного регистра
//	PORTC ^= (1<<0); 		//debug


		//////	 выключатель сигнализации (тумблер)		//////
		if (bit_is_set(PINC,PC5))							//
			{												//
				Bit_set(sensor, RESET);						//
			}												//
		//////////////////////////////////////////////////////



		//////			опрос геркона на обрыв			//////
		if (bit_is_clear(PINC,PC3))							//
			{												//
				Bit_set(sensor, HERCON); //Установил флаг	//
			}												//
		//////////////////////////////////////////////////////



		//////	  опрос вибродатчика ("0" - сработка)	 /////
		if (bit_is_clear(PINC,PC1))							//
			{												//
				Bit_set(sensor, VIBRO); //Установил флаг	//
			}												//
		//////////////////////////////////////////////////////



}
